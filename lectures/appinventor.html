<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>appinventor</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="appinventor_files/libs/clipboard/clipboard.min.js"></script>
<script src="appinventor_files/libs/quarto-html/quarto.js"></script>
<script src="appinventor_files/libs/quarto-html/popper.min.js"></script>
<script src="appinventor_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="appinventor_files/libs/quarto-html/anchor.min.js"></script>
<link href="appinventor_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="appinventor_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="appinventor_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="appinventor_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="appinventor_files/libs/bootstrap/bootstrap-e1410b04cc7f3ad098892ee0af4d0b3a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="app-inventor-quiz-tinydb-canvas-events-procedures-and-virtual-screens" class="level1">
<h1>App Inventor Quiz: TinyDB, Canvas, Events, Procedures, and Virtual Screens</h1>
<ol type="1">
<li><strong>Your art app has filled the canvas with drawings, but users want to start over. What’s the most efficient way to let them clear everything?</strong>
<ul>
<li>A. Set each pixel to white one by one</li>
<li>B. Use Canvas.Clear</li>
<li>C. Create a new canvas and replace the old one</li>
<li>D. Place a white rectangle over everything</li>
</ul></li>
<li><strong>Your game app needs to show a tutorial only the first time a user plays. How would you implement this?</strong>
<ul>
<li>A. Check in Screen.Initialize if a “tutorialShown” tag exists in TinyDB, if not, show the tutorial and then store “true” with that tag</li>
<li>B. Always show the tutorial during OnStart</li>
<li>C. Use a global variable to track if the tutorial has been shown</li>
<li>D. Ask the user each time if they want to see the tutorial</li>
</ul></li>
<li><strong>Your math quiz app needs to calculate the score based on correct answers and time taken. Which type of procedure would be most appropriate?</strong>
<ul>
<li>A. A procedure without result that updates a Score label</li>
<li>B. A procedure with result that returns the calculated score value</li>
<li>C. No procedure - just use the blocks directly in the Button.Click event</li>
<li>D. A procedure with multiple return values for score and time</li>
</ul></li>
<li><strong>You’re developing a drawing app that lets users choose their preferred brush color. What’s the best way to remember their color choice when they reopen the app?</strong>
<ul>
<li>A. Store it in a variable</li>
<li>B. Use TinyDB to save the color value</li>
<li>C. Save it to a text file</li>
<li>D. Use Firebase</li>
</ul></li>
<li><strong>Your quiz app uses virtual screens for different categories. A user completes the “History” category and moves to “Science.” What happens to their History progress?</strong>
<ul>
<li>A. It’s permanently deleted when switching screens</li>
<li>B. It’s preserved since the arrangement is just hidden, not destroyed</li>
<li>C. It’s automatically saved to TinyDB</li>
<li>D. It’s converted to points only</li>
</ul></li>
<li><strong>You want your drawing app to create rainbow lines that change color as the user draws. Where would you put the code to change the pen color?</strong>
<ul>
<li>A. In the Screen.Initialize event</li>
<li>B. In a Clock.Timer event</li>
<li>C. Inside the Canvas.Dragged event</li>
<li>D. In the Button.Click event</li>
</ul></li>
<li><strong>In your travel app, users navigate through multiple destination screens but want to return to the main menu quickly. What’s the best approach?</strong>
<ul>
<li>A. Add a “Home” button that uses multiple CloseScreen blocks</li>
<li>B. Use BackScreen repeatedly until reaching the main menu</li>
<li>C. Create a direct CloseScreen block to close all screens and return to the main menu</li>
<li>D. Restart the app</li>
</ul></li>
<li><strong>You’re creating a music player app. Which of these settings would NOT be appropriate to store in TinyDB?</strong>
<ul>
<li>A. Volume level preference</li>
<li>B. Dark/light theme preference</li>
<li>C. The actual music files</li>
<li>D. Last played song position</li>
</ul></li>
<li><strong>In your drawing app, users can drag shapes around the canvas. The shapes jump to random positions instead of following the finger smoothly. What’s the likely issue?</strong>
<ul>
<li>A. Not using the currentX and currentY parameters from the Dragged event</li>
<li>B. Forgetting to set Draggable to true</li>
<li>C. Missing the TouchUp event handler</li>
<li>D. The Canvas is too small</li>
</ul></li>
<li><strong>Your educational app needs to draw a coordinate system with X and Y axes. What’s the most efficient approach?</strong>
<ul>
<li>A. Use many small Canvas.DrawPoint calls</li>
<li>B. Use Canvas.DrawLine for each axis with appropriate coordinates</li>
<li>C. Use Canvas.DrawCircle with a very small radius</li>
<li>D. Use Canvas.DrawRect to create the lines</li>
</ul></li>
<li><strong>You’re creating a finger painting app for children. Which event would you use to track their finger movement and draw lines as they move?</strong>
<ul>
<li>A. Canvas.Touched</li>
<li>B. Canvas.Dragged</li>
<li>C. Canvas.Draw</li>
<li>D. Canvas.Moved</li>
</ul></li>
<li><strong>Your weather app shows temperature in Celsius by default, but users can switch to Fahrenheit. When they reopen the app, it shows their last selected unit. How would you implement this?</strong>
<ul>
<li>A. Create a TinyDB, store “C” or “F” with tag “tempUnit”, and check this value during Screen.Initialize</li>
<li>B. Use the app’s properties to store the preference</li>
<li>C. Always start with Celsius and let users change it each time</li>
<li>D. Use the Clock component to remember the last setting</li>
</ul></li>
<li><strong>Your note-taking app needs to process text in several ways (count words, check spelling, format paragraphs). What’s the best practice for organizing these functions?</strong>
<ul>
<li>A. Create one large procedure that does everything</li>
<li>B. Create separate procedures for each task and have them call each other when needed</li>
<li>C. Don’t use procedures - just use event handlers</li>
<li>D. Store each function in a separate TinyDB</li>
</ul></li>
<li><strong>Users of your task management app want a “Reset All Settings” option. How would you implement this most efficiently?</strong>
<ul>
<li>A. Store each setting with a separate tag and clear them one by one</li>
<li>B. Close and reopen the app</li>
<li>C. Use TinyDB.Clear to remove all stored values at once</li>
<li>D. Create a new TinyDB component to replace the existing one</li>
</ul></li>
<li><strong>A user of your quiz app completed 5 levels but deleted the app. After reinstalling it, they want to continue from level 6. Why couldn’t they?</strong>
<ul>
<li>A. TinyDB data is tied to the app installation and is deleted when the app is uninstalled</li>
<li>B. The user forgot their password</li>
<li>C. TinyDB has a time limit of one week</li>
<li>D. The levels were stored in a variable instead of TinyDB</li>
</ul></li>
<li><strong>You need to reset your game to its starting state in several different situations (when a level is completed, when the player loses, or when they press the reset button). What’s the best approach?</strong>
<ul>
<li>A. Define a procedure without result called “ResetGame” and call it from each event</li>
<li>B. Copy and paste the same reset blocks into each event handler</li>
<li>C. Use global variables to track when to reset</li>
<li>D. Create a new screen for each scenario</li>
</ul></li>
<li><strong>Your fitness tracking app needs to remember the user’s daily step goal. When they change it in the settings screen, which blocks would you use to save this new goal?</strong>
<ul>
<li>A. TinyDB.StoreValue with tags like “stepGoal”</li>
<li>B. File.SaveFile with the step goal as content</li>
<li>C. CloudDB.StoreValue to save it online</li>
<li>D. Just use a global variable</li>
</ul></li>
<li><strong>You’re designing a workout app with multiple training programs. How would you organize the interface using virtual screens?</strong>
<ul>
<li>A. Create VerticalArrangements for each program and control their visibility</li>
<li>B. Use multiple physical screens and navigate between them</li>
<li>C. Create one ScrollArrangement with all programs</li>
<li>D. Use multiple Image components to show different workouts</li>
</ul></li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>